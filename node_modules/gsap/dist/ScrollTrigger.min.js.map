{"version":3,"file":"ScrollTrigger.min.js","sources":["../src/ScrollTrigger.js"],"sourcesContent":["/*!\n * ScrollTrigger 3.4.0\n * https://greensock.com\n *\n * @license Copyright 2008-2020, GreenSock. All rights reserved.\n * Subject to the terms at https://greensock.com/standard-license or for\n * Club GreenSock members, the agreement issued with that membership.\n * @author: Jack Doyle, jack@greensock.com\n*/\n/* eslint-disable */\n\nlet gsap, _coreInitted, _win, _doc, _docEl, _body, _root, _resizeDelay, _raf, _request, _toArray, _clamp, _time2, _syncInterval, _refreshing, _pointerIsDown, _transformProp, _i, _prevWidth, _prevHeight, _autoRefresh,\n\t_limitCallbacks, // if true, we'll only trigger callbacks if the active state toggles, so if you scroll immediately past both the start and end positions of a ScrollTrigger (thus inactive to inactive), neither its onEnter nor onLeave will be called. This is useful during startup.\n\t_startup = 1,\n\t_proxies = [],\n\t_scrollers = [],\n\t_getTime = Date.now,\n\t_time1 = _getTime(),\n\t_lastScrollTime = 0,\n\t_enabled = 1,\n\t_passThrough = v => v,\n\t_windowExists = () => typeof(window) !== \"undefined\",\n\t_getGSAP = () => gsap || (_windowExists() && (gsap = window.gsap) && gsap.registerPlugin && gsap),\n\t_isViewport = e => !!~_root.indexOf(e),\n\t_getProxyProp = (element, property) => ~_proxies.indexOf(element) && _proxies[_proxies.indexOf(element) + 1][property],\n\t_getScrollFunc = (element, {s, sc}) => {\n\t\tlet i = _scrollers.indexOf(element),\n\t\t\tfunc = ~i ? _scrollers[i+1] : _getProxyProp(element, s) || (_isViewport(element) ? sc : function(value) { return arguments.length ? (element[s] = value) : element[s]; });\n\t\t!~i && _scrollers.push(element, func);\n\t\treturn func;\n\t},\n\t_getBoundsFunc = element => _getProxyProp(element, \"getBoundingClientRect\") || (_isViewport(element) ? () => {_winOffsets.width = _win.innerWidth; _winOffsets.height = _win.innerHeight; return _winOffsets;} : () => _getBounds(element)),\n\t_getSizeFunc = (scroller, isViewport, {d, d2, a}) => (a = _getProxyProp(scroller, \"getBoundingClientRect\")) ? () => a()[d] : () => (isViewport ? _win[\"inner\" + d2] : scroller[\"client\" + d2]) || 0,\n\t_getOffsetsFunc = (element, isViewport) => !isViewport || ~_proxies.indexOf(element) ? _getBoundsFunc(element) : () => _winOffsets,\n\t_maxScroll = (element, {s, d2, d, a}) => (s = \"scroll\" + d2) && (a = _getProxyProp(element, s)) ? a() - _getBoundsFunc(element)()[d] : _isViewport(element) ? Math.max(_docEl[s], _body[s]) - (_win[\"inner\" + d2] || _docEl[\"client\" + d2] || _body[\"client\" + d2]) : element[s] - element[\"offset\" + d2],\n\t_iterateAutoRefresh = (func, events) => {\n\t\tfor (let i = 0; i < _autoRefresh.length; i += 3) {\n\t\t\t(!events || ~events.indexOf(_autoRefresh[i+1])) && func(_autoRefresh[i], _autoRefresh[i+1], _autoRefresh[i+2]);\n\t\t}\n\t},\n\t_isString = value => typeof(value) === \"string\",\n\t_isFunction = value => typeof(value) === \"function\",\n\t_isNumber = value => typeof(value) === \"number\",\n\t_isObject = value => typeof(value) === \"object\",\n\t_abs = Math.abs,\n\t_scrollLeft = \"scrollLeft\",\n\t_scrollTop = \"scrollTop\",\n\t_left = \"left\",\n\t_top = \"top\",\n\t_right = \"right\",\n\t_bottom = \"bottom\",\n\t_width = \"width\",\n\t_height = \"height\",\n\t_Right = \"Right\",\n\t_Left = \"Left\",\n\t_Top = \"Top\",\n\t_Bottom = \"Bottom\",\n\t_padding = \"padding\",\n\t_margin = \"margin\",\n\t_Width = \"Width\",\n\t_Height = \"Height\",\n\t_px = \"px\",\n\t_horizontal = {s: _scrollLeft, p: _left, p2: _Left, os: _right, os2: _Right, d: _width, d2: _Width, a: \"x\", sc: function(value) { return arguments.length ? _win.scrollTo(value, _vertical.sc()) : _win.pageXOffset || _doc[_scrollLeft] || _docEl[_scrollLeft] || _body[_scrollLeft] || 0}},\n\t_vertical = {s: _scrollTop, p: _top, p2: _Top, os: _bottom, os2: _Bottom, d: _height, d2: _Height, a: \"y\", op: _horizontal, sc: function(value) { return arguments.length ? _win.scrollTo(_horizontal.sc(), value) : _win.pageYOffset || _doc[_scrollTop] || _docEl[_scrollTop] || _body[_scrollTop] || 0}},\n\t_getComputedStyle = element => _win.getComputedStyle(element),\n\t_makePositionable = element => element.style.position = (_getComputedStyle(element).position === \"absolute\") ? \"absolute\" : \"relative\", // if the element already has position: absolute, leave that, otherwise make it position: relative\n\t_setDefaults = (obj, defaults) => {\n\t\tfor (let p in defaults) {\n\t\t\t(p in obj) || (obj[p] = defaults[p]);\n\t\t}\n\t\treturn obj;\n\t},\n\t//_isInViewport = element => (element = _getBounds(element)) && !(element.top > (_win.innerHeight || _docEl.clientHeight) || element.bottom < 0 || element.left > (_win.innerWidth || _docEl.clientWidth) || element.right < 0) && element,\n\t_getBounds = (element, withoutTransforms) => {\n\t\tlet tween = withoutTransforms && _getComputedStyle(element)[_transformProp] !== \"matrix(1, 0, 0, 1, 0, 0)\" && gsap.to(element, {x: 0, y: 0, xPercent: 0, yPercent: 0, rotation: 0, rotationX: 0, rotationY: 0, scale: 1, skewX: 0, skewY: 0}).progress(1),\n\t\t\tbounds = element.getBoundingClientRect();\n\t\ttween && tween.progress(0).kill();\n\t\treturn bounds;\n\t},\n\t_getSize = (element, {d2}) => element[\"offset\" + d2] || element[\"client\" + d2] || 0,\n\t_getLabels = animation => {\n\t\treturn value => {\n\t\t\tlet a = [],\n\t\t\t\tlabels = animation.labels,\n\t\t\t\tduration = animation.duration(),\n\t\t\t\tp;\n\t\t\tfor (p in labels) {\n\t\t\t\ta.push(labels[p] / duration);\n\t\t\t}\n\t\t\treturn gsap.utils.snap(a, value);\n\t\t};\n\t},\n\t_multiListener = (func, element, types, callback) => types.split(\",\").forEach(type => func(element, type, callback)),\n\t_addListener = (element, type, func) => element.addEventListener(type, func, {passive: true}),\n\t_removeListener = (element, type, func) => element.removeEventListener(type, func),\n\t_markerDefaults = {startColor: \"green\", endColor: \"red\", indent: 0, fontSize: \"16px\", fontWeight:\"normal\"},\n\t_defaults = {toggleActions: \"play\", anticipatePin: 0},\n\t_keywords = {top: 0, left: 0, center: 0.5, bottom: 1, right: 1},\n\t_offsetToPx = (value, size) => {\n\t\tif (_isString(value)) {\n\t\t\tlet eqIndex = value.indexOf(\"=\"),\n\t\t\t\trelative = ~eqIndex ? +(value.charAt(eqIndex-1) + 1) * parseFloat(value.substr(eqIndex + 1)) : 0;\n\t\t\tif (relative) {\n\t\t\t\t(value.indexOf(\"%\") > eqIndex) && (relative *= size / 100);\n\t\t\t\tvalue = value.substr(0, eqIndex-1);\n\t\t\t}\n\t\t\tvalue = relative + ((value in _keywords) ? _keywords[value] * size : ~value.indexOf(\"%\") ? parseFloat(value) * size / 100 : parseFloat(value) || 0);\n\t\t}\n\t\treturn value;\n\t},\n\t_createMarker = (type, name, container, direction, {startColor, endColor, fontSize, indent, fontWeight}, offset, matchWidthEl) => {\n\t\tlet e = _doc.createElement(\"div\"),\n\t\t\tuseFixedPosition = _isViewport(container) || _getProxyProp(container, \"pinType\") === \"fixed\",\n\t\t\tisScroller = type.indexOf(\"scroller\") !== -1,\n\t\t\tparent = useFixedPosition ? _body : container,\n\t\t\tisStart = type.indexOf(\"start\") !== -1,\n\t\t\tcolor = isStart ? startColor : endColor,\n\t\t\tcss = \"border-color:\" + color + \";font-size:\" + fontSize + \";color:\" + color + \";font-weight:\" + fontWeight + \";pointer-events:none;white-space:nowrap;font-family:sans-serif,Arial;z-index:1000;padding:4px 8px;border-width:0;border-style:solid;\";\n\t\tcss += \"position:\" + (isScroller && useFixedPosition ? \"fixed;\" : \"absolute;\");\n\t\t(isScroller || !useFixedPosition) && (css += (direction === _vertical ? _right : _bottom) + \":\" + (offset + parseFloat(indent)) + \"px;\");\n\t\tmatchWidthEl && (css += \"box-sizing:border-box;text-align:left;width:\" + matchWidthEl.offsetWidth + \"px;\");\n\t\te._isStart = isStart;\n\t\te.setAttribute(\"class\", \"gsap-marker-\" + type);\n\t\te.style.cssText = css;\n\t\te.innerText = name || name === 0 ? type + \"-\" + name : type;\n\t\tparent.insertBefore(e, parent.children[0]);\n\t\te._offset = e[\"offset\" + direction.op.d2];\n\t\t_positionMarker(e, 0, direction, isStart);\n\t\treturn e;\n\t},\n\t_positionMarker = (marker, start, direction, flipped) => {\n\t\tlet vars = {display: \"block\"},\n\t\t\tside = direction[flipped ? \"os2\" : \"p2\"],\n\t\t\toppositeSide = direction[flipped ? \"p2\" : \"os2\"];\n\t\tmarker._isFlipped = flipped;\n\t\tvars[direction.a + \"Percent\"] = flipped ? -100 : 0;\n\t\tvars[direction.a] = flipped ? 1 : 0;\n\t\tvars[\"border\" + side + _Width] = 1;\n\t\tvars[\"border\" + oppositeSide + _Width] = 0;\n\t\tvars[direction.p] = start;\n\t\tgsap.set(marker, vars);\n\t},\n\t_triggers = [],\n\t_ids = {},\n\t_sync = () => _request || (_request = _raf(_updateAll)),\n\t_onScroll = () => {\n\t\tif (!_request) {\n\t\t\t_request = _raf(_updateAll);\n\t\t\t_lastScrollTime || _dispatch(\"scrollStart\");\n\t\t\t_lastScrollTime = _getTime();\n\t\t}\n\t},\n\t_onResize = () => !_refreshing && _resizeDelay.restart(true), // ignore resizes triggered by refresh()\n\t_listeners = {},\n\t_emptyArray = [],\n\t_media = [],\n\t_creatingMedia, // when ScrollTrigger.matchMedia() is called, we record the current media key here (like \"(min-width: 800px)\") so that we can assign it to everything that's created during that call. Then we can revert just those when necessary. In the ScrollTrigger's init() call, the _creatingMedia is recorded as a \"media\" property on the instance.\n\t_lastMediaTick,\n\t_onMediaChange = e => {\n\t\tlet tick = gsap.ticker.frame,\n\t\t\tmatches = [],\n\t\t\ti = 0;\n\t\tif (_lastMediaTick !== tick) {\n\t\t\t_revertAll();\n\t\t\tfor (; i < _media.length; i+=2) {\n\t\t\t\t_win.matchMedia(_media[i]).matches ? matches.push(i) : _revertAll(1, _media[i]); // Firefox doesn't update the \"matches\" property of the MediaQueryList object correctly - it only does so as it calls its change handler - so we must re-create a media query here to ensure it's accurate.\n\t\t\t}\n\t\t\t_revertRecorded(); // in case killing/reverting any of the animations actually added inline styles back.\n\t\t\tfor (i = 0; i < matches.length; i++) {\n\t\t\t\t_creatingMedia = _media[matches[i]];\n\t\t\t\t_media[matches[i]+1](e);\n\t\t\t}\n\t\t\t_creatingMedia = 0;\n\t\t\t_refreshAll(0, 1);\n\t\t\t_lastMediaTick = tick;\n\t\t}\n\t},\n\t_softRefresh = () => _removeListener(ScrollTrigger, \"scrollEnd\", _softRefresh) || _refreshAll(true),\n\t_dispatch = type => (_listeners[type] && _listeners[type].map(f => f())) || _emptyArray,\n\t_savedStyles = [], // when ScrollTrigger.saveStyles() is called, the inline styles are recorded in this Array in a sequential format like [element, cssText, gsCache, media]. This keeps it very memory-efficient and fast to iterate through.\n\t_revertRecorded = media => {\n\t\tfor (let i = 0; i < _savedStyles.length; i+=4) {\n\t\t\tif (!media || _savedStyles[i+3] === media) {\n\t\t\t\t_savedStyles[i].style.cssText = _savedStyles[i+1];\n\t\t\t\t_savedStyles[i+2].uncache = 1;\n\t\t\t}\n\t\t}\n\t},\n\t_revertAll = (kill, media) => {\n\t\tlet trigger;\n\t\tfor (_i = 0; _i < _triggers.length; _i++) {\n\t\t\ttrigger = _triggers[_i];\n\t\t\tif (!media || trigger.media === media) {\n\t\t\t\tif (kill) {\n\t\t\t\t\ttrigger.kill(1);\n\t\t\t\t} else {\n\t\t\t\t\ttrigger.scroll.rec || (trigger.scroll.rec = trigger.scroll()); // record the scroll positions so that in each refresh() we can ensure that it doesn't shift. Remember, pinning can make things change around, especially if the same element is pinned multiple times. If one was already recorded, don't re-record because unpinning may have occurred and made it shorter.\n\t\t\t\t\ttrigger.revert();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t_revertRecorded(media);\n\t\tmedia || _dispatch(\"revert\");\n\t},\n\t_refreshAll = (force, skipRevert) => {\n\t\tif (_lastScrollTime && !force) {\n\t\t\t_addListener(ScrollTrigger, \"scrollEnd\", _softRefresh);\n\t\t\treturn;\n\t\t}\n\t\tlet refreshInits = _dispatch(\"refreshInit\");\n\t\tskipRevert || _revertAll();\n\t\tfor (_i = 0; _i < _triggers.length; _i++) {\n\t\t\t_triggers[_i].refresh();\n\t\t}\n\t\trefreshInits.forEach(result => result && result.render && result.render(-1)); // if the onRefreshInit() returns an animation (typically a gsap.set()), revert it. This makes it easy to put things in a certain spot before refreshing for measurement purposes, and then put things back.\n\t\t_i = _triggers.length;\n\t\twhile (_i--) {\n\t\t\t_triggers[_i].scroll.rec = 0;\n\t\t}\n\t\t_dispatch(\"refresh\");\n\t},\n\t_updateAll = () => {\n\t\tlet l = _triggers.length,\n\t\t\ttime = _getTime(),\n\t\t\trecordVelocity = time - _time1 >= 50;\n\t\tif (recordVelocity) {\n\t\t\tif (_lastScrollTime && !_pointerIsDown && time - _lastScrollTime > 200) {\n\t\t\t\t_lastScrollTime = 0;\n\t\t\t\t_dispatch(\"scrollEnd\");\n\t\t\t}\n\t\t\t_time2 = _time1;\n\t\t\t_time1 = time;\n\t\t}\n\t\tfor (_i = 0; _i < l; _i++) {\n\t\t\t_triggers[_i] && _triggers[_i].update(0, recordVelocity);\n\t\t}\n\t\t_request = 0;\n\t},\n\t_propNamesToCopy = [_left, _top, _bottom, _right, _margin + _Bottom, _margin + _Right, _margin + _Top, _margin + _Left, \"display\", \"flexShrink\"],\n\t_stateProps = _propNamesToCopy.concat([_width, _height, \"boxSizing\", \"max\" + _Width, \"max\" + _Height, \"position\", _margin, _padding, _padding + _Top, _padding + _Right, _padding + _Bottom, _padding + _Left]),\n\t_swapPinOut = (pin, spacer, state) => {\n\t\t_setState(state);\n\t\tif (pin.parentNode === spacer) {\n\t\t\tlet parent = spacer.parentNode;\n\t\t\tif (parent) {\n\t\t\t\tparent.insertBefore(pin, spacer);\n\t\t\t\tparent.removeChild(spacer);\n\t\t\t}\n\t\t}\n\t},\n\t_swapPinIn = (pin, spacer, cs) => {\n\t\tif (pin.parentNode !== spacer) {\n\t\t\tlet i = _propNamesToCopy.length,\n\t\t\t\tspacerStyle = spacer.style,\n\t\t\t\tpinStyle = pin.style,\n\t\t\t\tp;\n\t\t\twhile (i--) {\n\t\t\t\tp = _propNamesToCopy[i];\n\t\t\t\tspacerStyle[p] = cs[p];\n\t\t\t}\n\t\t\tspacerStyle.position = cs.position === \"absolute\" ? \"absolute\" : \"relative\";\n\t\t\t(cs.display === \"inline\") && (spacerStyle.display = \"inline-block\");\n\t\t\tpinStyle[_bottom] = pinStyle[_right] = \"auto\";\n\t\t\tspacerStyle.overflow = \"visible\";\n\t\t\tspacerStyle.boxSizing = \"border-box\";\n\t\t\tspacerStyle[_width] = _getSize(pin, _horizontal) + _px;\n\t\t\tspacerStyle[_height] = _getSize(pin, _vertical) + _px;\n\t\t\tspacerStyle[_padding] = pinStyle[_margin] = pinStyle[_top] = pinStyle[_left] = \"0\";\n\t\t\tpinStyle[_width] = cs[_width];\n\t\t\tpinStyle[_height] = cs[_height];\n\t\t\tpinStyle[_padding] = cs[_padding];\n\t\t\tpin.parentNode.insertBefore(spacer, pin);\n\t\t\tspacer.appendChild(pin);\n\t\t}\n\t},\n\t_capsExp = /([A-Z])/g,\n\t_setState = state => {\n\t\tif (state) {\n\t\t\tlet style = state.t.style,\n\t\t\t\tl = state.length,\n\t\t\t\ti = 0,\n\t\t\t\tp, value;\n\t\t\tfor (; i < l; i +=2) {\n\t\t\t\tvalue = state[i+1];\n\t\t\t\tp = state[i];\n\t\t\t\tif (value) {\n\t\t\t\t\tstyle[p] = value;\n\t\t\t\t} else if (style[p]) {\n\t\t\t\t\tstyle.removeProperty(p.replace(_capsExp, \"-$1\").toLowerCase());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\t_getState = element => { // returns an array with alternating values like [property, value, property, value] and a \"t\" property pointing to the target (element). Makes it fast and cheap.\n\t\tlet l = _stateProps.length,\n\t\t\tstyle = element.style,\n\t\t\tstate = [],\n\t\t\ti = 0;\n\t\tfor (; i < l; i++) {\n\t\t\tstate.push(_stateProps[i], style[_stateProps[i]]);\n\t\t}\n\t\tstate.t = element;\n\t\treturn state;\n\t},\n\t_copyState = (state, override, omitOffsets) => {\n\t\tlet result = [],\n\t\t\tl = state.length,\n\t\t\ti = omitOffsets ? 8 : 0, // skip top, left, right, bottom if omitOffsets is true\n\t\t\tp;\n\t\tfor (; i < l; i += 2) {\n\t\t\tp = state[i];\n\t\t\tresult.push(p, (p in override) ? override[p] : state[i+1]);\n\t\t}\n\t\tresult.t = state.t;\n\t\treturn result;\n\t},\n\t_winOffsets = {left:0, top:0},\n\t_parsePosition = (value, trigger, scrollerSize, direction, scroll, marker, markerScroller, self, scrollerBounds, borderWidth, useFixedPosition, scrollerMax) => {\n\t\t_isFunction(value) && (value = value(self));\n\t\tif (_isString(value) && value.substr(0,3) === \"max\") {\n\t\t\tvalue = scrollerMax + (value.charAt(4) === \"=\" ? _offsetToPx(\"0\" + value.substr(3), scrollerSize) : 0);\n\t\t}\n\t\tif (!_isNumber(value)) {\n\t\t\t_isFunction(trigger) && (trigger = trigger(self));\n\t\t\tlet element = _toArray(trigger)[0] || _body,\n\t\t\t\tbounds = _getBounds(element) || {},\n\t\t\t\toffsets = value.split(\" \"),\n\t\t\t\tlocalOffset, globalOffset, display;\n\t\t\tif ((!bounds || (!bounds.left && !bounds.top)) && _getComputedStyle(element).display === \"none\") { // if display is \"none\", it won't report getBoundingClientRect() properly\n\t\t\t\tdisplay = element.style.display;\n\t\t\t\telement.style.display = \"block\";\n\t\t\t\tbounds = _getBounds(element);\n\t\t\t\tdisplay ? (element.style.display = display) : element.style.removeProperty(\"display\");\n\t\t\t}\n\t\t\tlocalOffset = _offsetToPx(offsets[0], bounds[direction.d]);\n\t\t\tglobalOffset = _offsetToPx(offsets[1] || \"0\", scrollerSize);\n\t\t\tvalue = bounds[direction.p] - scrollerBounds[direction.p] - borderWidth + localOffset + scroll - globalOffset;\n\t\t\tmarkerScroller && _positionMarker(markerScroller, globalOffset, direction, (scrollerSize - globalOffset < 20 || (markerScroller._isStart && globalOffset > 20)));\n\t\t\tscrollerSize -= scrollerSize - globalOffset; // adjust for the marker\n\t\t} else if (markerScroller) {\n\t\t\t_positionMarker(markerScroller, scrollerSize, direction, true);\n\t\t}\n\t\tif (marker) {\n\t\t\tlet position = value + scrollerSize,\n\t\t\t\tisStart = marker._isStart;\n\t\t\tscrollerMax = \"scroll\" + direction.d2;\n\t\t\t_positionMarker(marker, position, direction, (isStart && position > 20) || (!isStart && (useFixedPosition ? Math.max(_body[scrollerMax], _docEl[scrollerMax]) : marker.parentNode[scrollerMax]) <= position + 1));\n\t\t\tif (useFixedPosition) {\n\t\t\t\tscrollerBounds = _getBounds(markerScroller);\n\t\t\t\tuseFixedPosition && (marker.style[direction.op.p] = (scrollerBounds[direction.op.p] - direction.op.m - marker._offset) + _px);\n\t\t\t}\n\t\t}\n\t\treturn Math.round(value);\n\t},\n\t_prefixExp = /(?:webkit|moz|length)/i,\n\t_reparent = (element, parent) => {\n\t\tif (element.parentNode !== parent) {\n\t\t\tlet style = element.style,\n\t\t\t\tp, cs;\n\t\t\tif (parent === _body) {\n\t\t\t\telement._stOrig = style.cssText; // record original inline styles so we can revert them later\n\t\t\t\tcs = _getComputedStyle(element);\n\t\t\t\tfor (p in cs) { // must copy all relevant styles to ensure that nothing changes visually when we reparent to the <body>. Skip the vendor prefixed ones.\n\t\t\t\t\tif (!+p && !_prefixExp.test(p) && cs[p] && typeof style[p] === \"string\" && p !== \"0\") {\n\t\t\t\t\t\tstyle[p] = cs[p];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tstyle.cssText = element._stOrig;\n\t\t\t}\n\t\t\tparent.appendChild(element);\n\t\t}\n\t},\n\t// returns a function that can be used to tween the scroll position in the direction provided, and when doing so it'll add a .tween property to the FUNCTION itself, and remove it when the tween completes or gets killed. This gives us a way to have multiple ScrollTriggers use a central function for any given scroller and see if there's a scroll tween running (which would affect if/how things get updated)\n\t_getTweenCreator = (scroller, direction) => {\n\t\tlet getScroll = _getScrollFunc(scroller, direction),\n\t\t\tprop = \"_scroll\" + direction.p2, // add a tweenable property to the scroller that's a getter/setter function, like _scrollTop or _scrollLeft. This way, if someone does gsap.killTweensOf(scroller) it'll kill the scroll tween.\n\t\t\tlastScroll,\n\t\t\tgetTween = (scrollTo, vars, initialValue, change1, change2) => {\n\t\t\t\tlet tween = getTween.tween,\n\t\t\t\t\tonComplete = vars.onComplete,\n\t\t\t\t\tmodifiers = {};\n\t\t\t\ttween && tween.kill();\n\t\t\t\tlastScroll = getScroll();\n\t\t\t\tvars[prop] = scrollTo;\n\t\t\t\tvars.modifiers = modifiers;\n\t\t\t\tmodifiers[prop] = value => {\n\t\t\t\t\tif (Math.abs(getScroll() - lastScroll) > 7) { // if the user scrolls, kill the tween. Need a margin of error because some browsers like iOS Safari misreport the scroll position!\n\t\t\t\t\t\ttween.kill();\n\t\t\t\t\t\tgetTween.tween = 0;\n\t\t\t\t\t\tvalue = getScroll();\n\t\t\t\t\t} else if (change1) {\n\t\t\t\t\t\tvalue = initialValue + change1 * tween.ratio + change2 * tween.ratio * tween.ratio;\n\t\t\t\t\t}\n\t\t\t\t\treturn (lastScroll = Math.round(value));\n\t\t\t\t};\n\t\t\t\tvars.onComplete = () => {\n\t\t\t\t\tgetTween.tween = 0;\n\t\t\t\t\tonComplete && onComplete.call(tween);\n\t\t\t\t};\n\t\t\t\ttween = getTween.tween = gsap.to(scroller, vars);\n\t\t\t\treturn tween;\n\t\t\t};\n\t\tscroller[prop] = getScroll;\n\t\treturn getTween;\n\t};\n\n_horizontal.op = _vertical;\n\n\n\nexport class ScrollTrigger {\n\n\tconstructor(vars, animation) {\n\t\t_coreInitted || ScrollTrigger.register(gsap) || console.warn(\"Please gsap.registerPlugin(ScrollTrigger)\");\n\t\tthis.init(vars, animation);\n\t}\n\n\tinit(vars, animation) {\n\t\tthis.progress = 0;\n\t\tthis.vars && this.kill(1); // in case it's being initted again\n\t\tif (!_enabled) {\n\t\t\tthis.update = this.refresh = this.kill = _passThrough;\n\t\t\treturn;\n\t\t}\n\t\tvars = _setDefaults((_isString(vars) || _isNumber(vars) || vars.nodeType) ? {trigger: vars} : vars, _defaults);\n\t\tlet direction = vars.horizontal ? _horizontal : _vertical,\n\t\t\t{onUpdate, toggleClass, id, onToggle, onRefresh, scrub, trigger, pin, pinSpacing, invalidateOnRefresh, anticipatePin, onScrubComplete, onSnapComplete, once, snap, pinReparent} = vars,\n\t\t\tisToggle = !scrub && scrub !== 0,\n\t\t\tscroller = _toArray(vars.scroller || _win)[0],\n\t\t\tscrollerCache = gsap.core.getCache(scroller),\n\t\t\tisViewport = _isViewport(scroller),\n\t\t\tuseFixedPosition = isViewport || _getProxyProp(scroller, \"pinType\") === \"fixed\",\n\t\t\tcallbacks = [vars.onEnter, vars.onLeave, vars.onEnterBack, vars.onLeaveBack],\n\t\t\ttoggleActions = isToggle && (once ? \"play\" : vars.toggleActions).split(\" \"),\n\t\t\tmarkers = \"markers\" in vars ? vars.markers : _defaults.markers,\n\t\t\tborderWidth = isViewport ? 0 : parseFloat(_getComputedStyle(scroller)[\"border\" + direction.p2 + _Width]) || 0,\n\t\t\tself = this,\n\t\t\tonRefreshInit = vars.onRefreshInit && (() => vars.onRefreshInit(self)),\n\t\t\tgetScrollerSize = _getSizeFunc(scroller, isViewport, direction),\n\t\t\tgetScrollerOffsets = _getOffsetsFunc(scroller, isViewport),\n\t\t\ttweenTo, pinCache, snapFunc, isReverted, scroll1, scroll2, start, end, markerStart, markerEnd, markerStartTrigger, markerEndTrigger, markerVars,\n\t\t\tchange, pinOriginalState, pinActiveState, pinState, spacer, offset, pinGetter, pinSetter, pinStart, pinChange, spacingStart, spacingActive, markerStartSetter,\n\t\t\tmarkerEndSetter, cs, snap1, snap2, scrubScrollTime, scrubTween, scrubSmooth, snapDurClamp, snapDelayedCall, enabled, prevProgress, prevScroll, prevAnimProgress;\n\n\t\tself.media = _creatingMedia;\n\t\tanticipatePin *= 45;\n\t\t_triggers.push(self);\n\t\tself.scroller = scroller;\n\t\tself.scroll = _getScrollFunc(scroller, direction);\n\t\tscroll1 = self.scroll();\n\t\tself.vars = vars;\n\t\tanimation = animation || vars.animation;\n\t\tscrollerCache.tweenScroll = scrollerCache.tweenScroll || {\n\t\t\ttop: _getTweenCreator(scroller, _vertical),\n\t\t\tleft: _getTweenCreator(scroller, _horizontal)\n\t\t};\n\t\tself.tweenTo = tweenTo = scrollerCache.tweenScroll[direction.p];\n\t\tif (animation) {\n\t\t\tanimation.vars.lazy = false;\n\t\t\tanimation._initted || (animation.vars.immediateRender !== false && vars.immediateRender !== false && animation.render(0, true, true));\n\t\t\tself.animation = animation.pause();\n\t\t\tanimation.scrollTrigger = self;\n\t\t\tscrubSmooth = _isNumber(scrub) && scrub;\n\t\t\tscrubSmooth && (scrubTween = gsap.to(animation, {ease: \"power3\", duration: scrubSmooth, onComplete: () => onScrubComplete && onScrubComplete(self)}));\n\t\t\tsnap1 = 0;\n\t\t\tid || (id = animation.vars.id);\n\t\t}\n\t\tif (snap) {\n\t\t\t_isObject(snap) || (snap = {snapTo: snap});\n\t\t\tgsap.set(isViewport ? [_body, _docEl] : scroller, {scrollBehavior: \"auto\"}); // smooth scrolling doesn't work with snap.\n\t\t\tsnapFunc = _isFunction(snap.snapTo) ? snap.snapTo : snap.snapTo === \"labels\" ? _getLabels(animation) : gsap.utils.snap(snap.snapTo);\n\t\t\tsnapDurClamp = snap.duration || {min: 0.1, max: 2};\n\t\t\tsnapDurClamp = _isObject(snapDurClamp) ? _clamp(snapDurClamp.min, snapDurClamp.max) : _clamp(snapDurClamp, snapDurClamp);\n\t\t\tsnapDelayedCall = gsap.delayedCall(snap.delay || (scrubSmooth / 2) || 0.1, () => {\n\t\t\t\tif (!_lastScrollTime || (_lastScrollTime === scrubScrollTime && !_pointerIsDown)) {\n\t\t\t\t\tlet totalProgress = animation && !isToggle ? animation.totalProgress() : self.progress,\n\t\t\t\t\t\tvelocity = ((totalProgress - snap2) / (_getTime() - _time2) * 1000) || 0,\n\t\t\t\t\t\tchange1 = _abs(velocity / 2) * velocity / 0.185,\n\t\t\t\t\t\tnaturalEnd = totalProgress + change1,\n\t\t\t\t\t\tendValue = _clamp(0, 1, snapFunc(naturalEnd, self)),\n\t\t\t\t\t\tchange2 = endValue - totalProgress - change1,\n\t\t\t\t\t\tscroll = self.scroll(),\n\t\t\t\t\t\tendScroll = Math.round(start + endValue * change),\n\t\t\t\t\t\ttween = tweenTo.tween;\n\t\t\t\t\tif (scroll <= end && scroll >= start) {\n\t\t\t\t\t\tif (tween && !tween._initted) { // there's an overlapping snap! So we must figure out which one is closer and let that tween live.\n\t\t\t\t\t\t\tif (tween.data <= Math.abs(endScroll - scroll)) {\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttween.kill();\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttweenTo(endScroll, {\n\t\t\t\t\t\t\tduration: snapDurClamp(_abs( (Math.max(_abs(naturalEnd - totalProgress), _abs(endValue - totalProgress)) * 0.185 / velocity / 0.05) || 0)),\n\t\t\t\t\t\t\tease: snap.ease || \"power3\",\n\t\t\t\t\t\t\tdata: Math.abs(endScroll - scroll), // record the distance so that if another snap tween occurs (conflict) we can prioritize the closest snap.\n\t\t\t\t\t\t\tonComplete: () => {\n\t\t\t\t\t\t\t\tsnap1 = snap2 = animation && !isToggle ? animation.totalProgress() : self.progress;\n\t\t\t\t\t\t\t\tonSnapComplete && onSnapComplete(self);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}, start + totalProgress * change, change1 * change, change2 * change);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tsnapDelayedCall.restart(true);\n\t\t\t\t}\n\t\t\t}).pause();\n\t\t}\n\t\tid && (_ids[id] = self);\n\t\ttrigger = self.trigger = _toArray(trigger || pin)[0];\n\t\tpin = pin === true ? trigger : _toArray(pin)[0];\n\t\t_isString(toggleClass) && (toggleClass = {targets: trigger, className: toggleClass});\n\t\tif (pin) {\n\t\t\t(pinSpacing === false || pinSpacing === _margin) || (pinSpacing = _getComputedStyle(pin.parentNode).display === \"flex\" ? false : _padding); // if the parent is display: flex, don't apply pinSpacing by default.\n\t\t\tself.pin = pin;\n\t\t\tvars.force3D !== false && gsap.set(pin, {force3D: true});\n\t\t\tpinCache = gsap.core.getCache(pin);\n\t\t\tif (!pinCache.spacer) { // record the spacer and pinOriginalState on the cache in case someone tries pinning the same element with MULTIPLE ScrollTriggers - we don't want to have multiple spacers or record the \"original\" pin state after it has already been affected by another ScrollTrigger.\n\t\t\t\tpinCache.spacer = spacer = _doc.createElement(\"div\");\n\t\t\t\tspacer.setAttribute(\"class\", \"pin-spacer\" + (id ? \" pin-spacer-\" + id : \"\"));\n\t\t\t\tpinCache.pinState = pinOriginalState = _getState(pin);\n\t\t\t} else {\n\t\t\t\tpinOriginalState = pinCache.pinState;\n\t\t\t}\n\t\t\tself.spacer = spacer = pinCache.spacer;\n\t\t\tcs = _getComputedStyle(pin);\n\t\t\tspacingStart = cs[pinSpacing + direction.os2];\n\t\t\tpinGetter = gsap.getProperty(pin);\n\t\t\tpinSetter = gsap.quickSetter(pin, direction.a, _px);\n\t\t\t_swapPinIn(pin, spacer, cs);\n\t\t\tpinState = _getState(pin);\n\t\t}\n\t\tif (markers) {\n\t\t\tmarkerVars = _isObject(markers) ? _setDefaults(markers, _markerDefaults) : _markerDefaults;\n\t\t\tmarkerStartTrigger = _createMarker(\"scroller-start\", id, scroller, direction, markerVars, 0);\n\t\t\tmarkerEndTrigger = _createMarker(\"scroller-end\", id, scroller, direction, markerVars, 0, markerStartTrigger);\n\t\t\toffset = markerStartTrigger[\"offset\" + direction.op.d2];\n\t\t\tmarkerStart = _createMarker(\"start\", id, scroller, direction, markerVars, offset);\n\t\t\tmarkerEnd =_createMarker(\"end\", id, scroller, direction, markerVars, offset);\n\t\t\tif (!useFixedPosition) {\n\t\t\t\t_makePositionable(scroller);\n\t\t\t\tgsap.set([markerStartTrigger, markerEndTrigger], {force3D: true});\n\t\t\t\tmarkerStartSetter = gsap.quickSetter(markerStartTrigger, direction.a, _px);\n\t\t\t\tmarkerEndSetter = gsap.quickSetter(markerEndTrigger, direction.a, _px);\n\t\t\t}\n\t\t}\n\n\t\tself.revert = revert => {\n\t\t\tlet r = revert !== false,\n\t\t\t\tprevRefreshing = _refreshing;\n\t\t\tif (r !== isReverted) {\n\t\t\t\tif (r) {\n\t\t\t\t\tprevScroll = Math.max(self.scroll(), self.scroll.rec || 0); // record the scroll so we can revert later (repositioning/pinning things can affect scroll position). In the static refresh() method, we first record all the scroll positions as a reference.\n\t\t\t\t\tprevProgress = self.progress;\n\t\t\t\t\tprevAnimProgress = animation && animation.progress();\n\t\t\t\t\tmarkerStart && [markerStart, markerEnd, markerStartTrigger, markerEndTrigger].forEach(m => m.style.display = \"none\");\n\t\t\t\t}\n\n\t\t\t\t_refreshing = 1;\n\t\t\t\tself.update(r); // make sure the pin is back in its original position so that all the measurements are correct.\n\t\t\t\t_refreshing = prevRefreshing;\n\t\t\t\tpin && r && _swapPinOut(pin, spacer, pinOriginalState);\n\t\t\t\tisReverted = r;\n\t\t\t}\n\t\t}\n\n\n\t\tself.refresh = soft => {\n\t\t\tif (_refreshing || !enabled) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (pin && soft && _lastScrollTime) {\n\t\t\t\t_addListener(ScrollTrigger, \"scrollEnd\", _softRefresh);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t_refreshing = 1;\n\t\t\tscrubTween && scrubTween.kill();\n\t\t\tinvalidateOnRefresh && animation && animation.progress(0).invalidate();\n\t\t\tisReverted || self.revert();\n\t\t\tlet size = getScrollerSize(),\n\t\t\t\tscrollerBounds = getScrollerOffsets(),\n\t\t\t\tmax = _maxScroll(scroller, direction),\n\t\t\t\toffset = 0,\n\t\t\t\totherPinOffset = 0,\n\t\t\t\tparsedEnd = vars.end,\n\t\t\t\tparsedEndTrigger = vars.endTrigger || trigger,\n\t\t\t\tparsedStart = vars.start || (pin || !trigger ? \"0 0\" : \"0 100%\"),\n\t\t\t\tpinIndex = pin && Math.max(0, _triggers.indexOf(self)) || 0,\n\t\t\t\tcs, bounds, scroll, isVertical, override, i, curTrigger;\n\t\t\tif (pinIndex) { // user might try to pin the same element more than once, so we must find any prior triggers with the same pin, revert them, and determine how long they're pinning so that we can offset things appropriately. Make sure we revert from last to first so that things \"rewind\" properly.\n\t\t\t\ti = pinIndex;\n\t\t\t\twhile (i--) {\n\t\t\t\t\t_triggers[i].pin === pin && _triggers[i].revert();\n\t\t\t\t}\n\t\t\t}\n\t\t\tstart = _parsePosition(parsedStart, trigger, size, direction, self.scroll(), markerStart, markerStartTrigger, self, scrollerBounds, borderWidth, useFixedPosition, max) || (pin ? -0.001 : 0);\n\t\t\t_isFunction(parsedEnd) && (parsedEnd = parsedEnd(self));\n\t\t\tif (_isString(parsedEnd) && !parsedEnd.indexOf(\"+=\")) {\n\t\t\t\tif (~parsedEnd.indexOf(\" \")) {\n\t\t\t\t\tparsedEnd = (_isString(parsedStart) ? parsedStart.split(\" \")[0] : \"\") + parsedEnd;\n\t\t\t\t} else {\n\t\t\t\t\toffset = _offsetToPx(parsedEnd.substr(2), size);\n\t\t\t\t\tparsedEnd = _isString(parsedStart) ? parsedStart : start + offset; // _parsePosition won't factor in the offset if the start is a number, so do it here.\n\t\t\t\t\tparsedEndTrigger = trigger;\n\t\t\t\t}\n\t\t\t}\n\t\t\tend = Math.max(start, _parsePosition(parsedEnd || (parsedEndTrigger ? \"100% 0\" : max), parsedEndTrigger, size, direction, self.scroll() + offset, markerEnd, markerEndTrigger, self, scrollerBounds, borderWidth, useFixedPosition, max)) || -0.001;\n\t\t\tchange = (end - start) || ((start -= 0.01) && 0.001);\n\t\t\tif (pin) {\n\t\t\t\ti = pinIndex;\n\t\t\t\twhile (i--) {\n\t\t\t\t\tcurTrigger = _triggers[i];\n\t\t\t\t\tif (curTrigger.pin === pin && curTrigger.start - curTrigger._pinPush < start) {\n\t\t\t\t\t\totherPinOffset += curTrigger.end - curTrigger.start;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tstart += otherPinOffset;\n\t\t\t\tend += otherPinOffset;\n\t\t\t\tself._pinPush = otherPinOffset;\n\t\t\t\tif (markerStart && otherPinOffset) { // offset the markers if necessary\n\t\t\t\t\tcs = {};\n\t\t\t\t\tcs[direction.a] = \"+=\" + otherPinOffset;\n\t\t\t\t\tgsap.set([markerStart, markerEnd], cs);\n\t\t\t\t}\n\t\t\t\tcs = _getComputedStyle(pin);\n\t\t\t\tisVertical = (direction === _vertical);\n\t\t\t\tscroll = self.scroll(); // recalculate because the triggers can affect the scroll\n\t\t\t\tpinStart = parseFloat(pinGetter(direction.a)) + otherPinOffset;\n\t\t\t\t_swapPinIn(pin, spacer, cs);\n\t\t\t\tpinState = _getState(pin);\n\t\t\t\t// transforms will interfere with the top/left/right/bottom placement, so remove them temporarily. getBoundingClientRect() factors in transforms.\n\t\t\t\tbounds = _getBounds(pin, true);\n\t\t\t\tif (pinSpacing) {\n\t\t\t\t\tspacer.style[pinSpacing + direction.os2] = change + otherPinOffset + _px;\n\t\t\t\t\tspacingActive = (pinSpacing === _padding) ? _getSize(pin, direction) + change + otherPinOffset : 0;\n\t\t\t\t\tspacingActive && (spacer.style[direction.d] = spacingActive + _px); // for box-sizing: border-box (must include padding).\n\t\t\t\t\tuseFixedPosition && self.scroll(prevScroll);\n\t\t\t\t}\n\t\t\t\tif (useFixedPosition) {\n\t\t\t\t\toverride = {\n\t\t\t\t\t\ttop: (bounds.top + (isVertical ? scroll - start : 0)) + _px,\n\t\t\t\t\t\tleft: (bounds.left + (isVertical ? 0 : scroll - start)) + _px,\n\t\t\t\t\t\tboxSizing: \"border-box\",\n\t\t\t\t\t\tposition: \"fixed\"\n\t\t\t\t\t};\n\t\t\t\t\toverride[_width] = override[\"max\" + _Width] = Math.ceil(bounds.width) + _px;\n\t\t\t\t\toverride[_height] = override[\"max\" + _Height] = Math.ceil(bounds.height) + _px;\n\t\t\t\t\toverride[_margin] = override[_margin + _Top] = override[_margin + _Right] = override[_margin + _Bottom] = override[_margin + _Left] = \"0\";\n\t\t\t\t\toverride[_padding] = cs[_padding];\n\t\t\t\t\toverride[_padding + _Top] = cs[_padding + _Top];\n\t\t\t\t\toverride[_padding + _Right] = cs[_padding + _Right];\n\t\t\t\t\toverride[_padding + _Bottom] = cs[_padding + _Bottom];\n\t\t\t\t\toverride[_padding + _Left] = cs[_padding + _Left];\n\t\t\t\t\tpinActiveState = _copyState(pinOriginalState, override, pinReparent);\n\t\t\t\t}\n\t\t\t\tif (animation) { // the animation might be affecting the transform, so we must jump to the end, check the value, and compensate accordingly. Otherwise, when it becomes unpinned, the pinSetter() will get set to a value that doesn't include whatever the animation did.\n\t\t\t\t\tanimation.progress(1, true);\n\t\t\t\t\tpinChange = pinGetter(direction.a) - pinStart + change + otherPinOffset;\n\t\t\t\t\tchange !== pinChange && pinActiveState.splice(pinActiveState.length - 2, 2); // transform is the last property/value set in the state Array. Since the animation is controlling that, we should omit it.\n\t\t\t\t\tanimation.progress(0, true);\n\t\t\t\t} else {\n\t\t\t\t\tpinChange = change\n\t\t\t\t}\n\t\t\t\tif (pinIndex) { // make sure we revert from first to last to make sure things reach their end state properly\n\t\t\t\t\tfor (i = 0; i < pinIndex; i++) {\n\t\t\t\t\t\t_triggers[i].pin === pin && _triggers[i].revert(false);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (trigger && self.scroll()) { // it may be INSIDE a pinned element, so walk up the tree and look for any elements with _pinOffset to compensate because anything with pinSpacing that's already scrolled would throw off the measurements in getBoundingClientRect()\n\t\t\t\tbounds = trigger.parentNode;\n\t\t\t\twhile (bounds && bounds !== _body) {\n\t\t\t\t\tif (bounds._pinOffset) {\n\t\t\t\t\t\tstart -= bounds._pinOffset;\n\t\t\t\t\t\tend -= bounds._pinOffset;\n\t\t\t\t\t}\n\t\t\t\t\tbounds = bounds.parentNode;\n\t\t\t\t}\n\t\t\t}\n\t\t\tself.start = start;\n\t\t\tself.end = end;\n\t\t\tscroll1 = scroll2 = self.scroll(); // reset velocity\n\t\t\tscroll1 < prevScroll && self.scroll(prevScroll);\n\t\t\tself.revert(false);\n\t\t\t_refreshing = 0;\n\t\t\tprevAnimProgress && isToggle && animation.progress(prevAnimProgress, true);\n\t\t\tif (prevProgress !== self.progress) { // ensures that the direction is set properly (when refreshing, progress is set back to 0 initially, then back again to wherever it needs to be) and that callbacks are triggered.\n\t\t\t\tscrubTween && animation.totalProgress(prevProgress, true); // to avoid issues where animation callbacks like onStart aren't triggered.\n\t\t\t\tself.progress = prevProgress;\n\t\t\t\tself.update();\n\t\t\t}\n\t\t\tpin && pinSpacing && (spacer._pinOffset = Math.round(self.progress * pinChange));\n\t\t\tonRefresh && onRefresh(self);\n\t\t};\n\n\t\tself.getVelocity = () => ((self.scroll() - scroll2) / (_getTime() - _time2) * 1000) || 0;\n\n\t\tself.update = (reset, recordVelocity) => {\n\t\t\tlet scroll = self.scroll(),\n\t\t\t\tp = reset ? 0 : (scroll - start) / change,\n\t\t\t\tclipped = p < 0 ? 0 : p > 1 ? 1 : p || 0,\n\t\t\t\tprevProgress = self.progress,\n\t\t\t\tisActive, wasActive, toggleState, action, stateChanged, toggled;\n\t\t\tif (recordVelocity) {\n\t\t\t\tscroll2 = scroll1;\n\t\t\t\tscroll1 = scroll;\n\t\t\t\tif (snap) {\n\t\t\t\t\tsnap2 = snap1;\n\t\t\t\t\tsnap1 = animation && !isToggle ? animation.totalProgress() : clipped;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// anticipate the pinning a few ticks ahead of time based on velocity to avoid a visual glitch due to the fact that most browsers do scrolling on a separate thread (not synced with requestAnimationFrame).\n\t\t\t(anticipatePin && !clipped && pin && !_refreshing && !_startup && _lastScrollTime && start < scroll + ((scroll - scroll2) / (_getTime() - _time2)) * anticipatePin) && (clipped = 0.0001);\n\t\t\tif (clipped !== prevProgress && enabled) {\n\t\t\t\tisActive = self.isActive = !!clipped && clipped < 1;\n\t\t\t\twasActive = !!prevProgress && prevProgress < 1;\n\t\t\t\ttoggled = isActive !== wasActive;\n\t\t\t\tstateChanged = toggled || !!clipped !== !!prevProgress; // could go from start all the way to end, thus it didn't toggle but it did change state in a sense (may need to fire a callback)\n\t\t\t\tself.direction = clipped > prevProgress ? 1 : -1;\n\t\t\t\tself.progress = clipped;\n\t\t\t\tif (!isToggle) {\n\t\t\t\t\tif (scrubTween && !_refreshing && !_startup) {\n\t\t\t\t\t\tscrubTween.vars.totalProgress = clipped;\n\t\t\t\t\t\tscrubTween.invalidate().restart();\n\t\t\t\t\t} else if (animation) {\n\t\t\t\t\t\tanimation.totalProgress(clipped, !!_refreshing);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (pin) {\n\t\t\t\t\treset && pinSpacing && (spacer.style[pinSpacing + direction.os2] = spacingStart);\n\t\t\t\t\tif (!useFixedPosition) {\n\t\t\t\t\t\tpinSetter(pinStart + pinChange * clipped);\n\t\t\t\t\t} else if (stateChanged) {\n\t\t\t\t\t\taction = !reset && clipped > prevProgress && end + 1 > scroll && scroll + 1 >= _maxScroll(scroller, direction); // if it's at the VERY end of the page, don't switch away from position: fixed because it's pointless and it could cause a brief flash when the user scrolls back up (when it gets pinned again)\n\t\t\t\t\t\tif (pinReparent) {\n\t\t\t\t\t\t\tif (!_refreshing && (isActive || action)) {\n\t\t\t\t\t\t\t\tlet bounds = _getBounds(pin, true),\n\t\t\t\t\t\t\t\t\toffset = scroll - start;\n\t\t\t\t\t\t\t\tpin.style.top = (bounds.top + (direction === _vertical ? offset : 0)) + _px;\n\t\t\t\t\t\t\t\tpin.style.left = (bounds.left + (direction === _vertical ? 0 : offset)) + _px;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t_reparent(pin, !_refreshing && (isActive || action) ? _body : spacer);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t_setState(isActive || action ? pinActiveState : pinState);\n\t\t\t\t\t\t(pinChange !== change && clipped < 1 && isActive) || pinSetter(pinStart + (clipped === 1 && !action ? pinChange : 0));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (snap && !tweenTo.tween && !_refreshing && !_startup) {\n\t\t\t\t\tscrubScrollTime = _lastScrollTime;\n\t\t\t\t\tsnapDelayedCall.restart(true);\n\t\t\t\t}\n\t\t\t\ttoggleClass && toggled && (!once || isActive) && _toArray(toggleClass.targets).forEach(el => el.classList[isActive ? \"add\" : \"remove\"](toggleClass.className)); // classes could affect positioning, so do it even if reset or refreshing is true.\n\t\t\t\tonUpdate && !isToggle && !reset && onUpdate(self);\n\t\t\t\tif (stateChanged && !_refreshing) {\n\t\t\t\t\ttoggleState = clipped && !prevProgress ? 0 : clipped === 1 ? 1 : prevProgress === 1 ? 2 : 3; // 0 = enter, 1 = leave, 2 = enterBack, 3 = leaveBack (we prioritize the FIRST encounter, thus if you scroll really fast past the onEnter and onLeave in one tick, it'd prioritize onEnter.\n\t\t\t\t\tif (isToggle) {\n\t\t\t\t\t\taction = (!toggled && toggleActions[toggleState + 1] !== \"none\" && toggleActions[toggleState + 1]) || toggleActions[toggleState]; // if it didn't toggle, that means it shot right past and since we prioritize the \"enter\" action, we should switch to the \"leave\" in this case (but only if one is defined)\n\t\t\t\t\t\tif (animation && (action === \"complete\" || action === \"reset\" || action in animation)) {\n\t\t\t\t\t\t\tif (action === \"complete\") {\n\t\t\t\t\t\t\t\tanimation.pause().totalProgress(1);\n\t\t\t\t\t\t\t} else if (action === \"reset\") {\n\t\t\t\t\t\t\t\tanimation.restart(true).pause();\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tanimation[action]();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tonUpdate && onUpdate(self);\n\t\t\t\t\t}\n\t\t\t\t\tif (toggled || !_limitCallbacks) { // on startup, the page could be scrolled and we don't want to fire callbacks that didn't toggle. For example onEnter shouldn't fire if the ScrollTrigger isn't actually entered.\n\t\t\t\t\t\tonToggle && toggled && onToggle(self);\n\t\t\t\t\t\tcallbacks[toggleState] && callbacks[toggleState](self);\n\t\t\t\t\t\tonce && (clipped === 1 ? self.kill() : (callbacks[toggleState] = 0)); // a callback shouldn't be called again if once is true.\n\t\t\t\t\t\tif (!toggled) { // it's possible to go completely past, like from before the start to after the end (or vice-versa) in which case BOTH callbacks should be fired in that order\n\t\t\t\t\t\t\ttoggleState = clipped === 1 ? 1 : 3;\n\t\t\t\t\t\t\tcallbacks[toggleState] && callbacks[toggleState](self);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if (isToggle && onUpdate && !_refreshing) {\n\t\t\t\t\tonUpdate(self);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// update absolutely-positioned markers (only if the scroller isn't the viewport)\n\t\t\tif (markerEndSetter) {\n\t\t\t\tmarkerStartSetter(scroll + (markerStartTrigger._isFlipped ? 1 : 0));\n\t\t\t\tmarkerEndSetter(scroll);\n\t\t\t}\n\t\t};\n\n\t\tself.enable = () => {\n\t\t\tif (!enabled) {\n\t\t\t\tenabled = true;\n\t\t\t\t_addListener(scroller, \"resize\", _onResize);\n\t\t\t\t_addListener(scroller, \"scroll\", _onScroll);\n\t\t\t\tonRefreshInit && _addListener(ScrollTrigger, \"refreshInit\", onRefreshInit);\n\t\t\t\t!animation || !animation.add ? self.refresh() : gsap.delayedCall(0.01, self.refresh) && (change = 0.01) && (start = end = 0); // if the animation is a timeline, it may not have been populated yet, so it wouldn't render at the proper place on the first refresh(), thus we should schedule one for the next tick.\n\t\t\t}\n\t\t};\n\n\t\tself.disable = reset => {\n\t\t\tif (enabled) {\n\t\t\t\treset !== false && self.revert();\n\t\t\t\tenabled = self.isActive = false;\n\t\t\t\tscrubTween && scrubTween.pause();\n\t\t\t\tpin && _swapPinOut(pin, spacer, pinOriginalState);\n\t\t\t\tpinCache && (pinCache.uncache = 1);\n\t\t\t\tonRefreshInit && _removeListener(ScrollTrigger, \"refreshInit\", onRefreshInit);\n\t\t\t\tif (snapDelayedCall) {\n\t\t\t\t\tsnapDelayedCall.pause();\n\t\t\t\t\ttweenTo.tween && tweenTo.tween.kill();\n\t\t\t\t}\n\t\t\t\tif (!isViewport) {\n\t\t\t\t\tlet i = _triggers.length;\n\t\t\t\t\twhile (i--) {\n\t\t\t\t\t\tif (_triggers[i].scroller === scroller && _triggers[i] !== self) {\n\t\t\t\t\t\t\treturn; //don't remove the listeners if there are still other triggers referencing it.\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t_removeListener(scroller, \"resize\", _onResize);\n\t\t\t\t\t_removeListener(scroller, \"scroll\", _onScroll);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tself.kill = revert => {\n\t\t\tself.disable(revert);\n\t\t\tid && (delete _ids[id]);\n\t\t\tlet i = _triggers.indexOf(self);\n\t\t\t_triggers.splice(i, 1);\n\t\t\ti === _i && _i--; // if we're in the middle of a refresh() or update(), splicing would cause skips in the index, so adjust...\n\t\t\tif (animation) {\n\t\t\t\tanimation.scrollTrigger = null;\n\t\t\t\trevert && animation.render(-1);\n\t\t\t\tanimation.kill();\n\t\t\t}\n\t\t\tmarkerStart && [markerStart, markerEnd, markerStartTrigger, markerEndTrigger].forEach(m => m.parentNode.removeChild(m));\n\t\t\tpinCache && (pinCache.uncache = 1);\n\t\t};\n\n\t\tself.enable();\n\t}\n\n\n\tstatic register(core) {\n\t\tif (!_coreInitted) {\n\t\t\tgsap = core || _getGSAP();\n\t\t\tif (_windowExists() && window.document) {\n\t\t\t\t_win = window;\n\t\t\t\t_doc = document;\n\t\t\t\t_docEl = _doc.documentElement;\n\t\t\t\t_body = _doc.body;\n\t\t\t}\n\t\t\tif (gsap) {\n\t\t\t\t_toArray = gsap.utils.toArray;\n\t\t\t\t_clamp = gsap.utils.clamp;\n\t\t\t\tgsap.core.globals(\"ScrollTrigger\", ScrollTrigger); // must register the global manually because in Internet Explorer, functions (classes) don't have a \"name\" property.\n\t\t\t\tif (_body) {\n\t\t\t\t\t_raf = _win.requestAnimationFrame || (f => setTimeout(f, 16));\n\t\t\t\t\t_addListener(_win, \"mousewheel\", _onScroll);\n\t\t\t\t\t_root = [_win, _doc, _docEl, _body];\n\t\t\t\t\t_addListener(_doc, \"scroll\", _onScroll); // some browsers (like Chrome), the window stops dispatching scroll events on the window if you scroll really fast, but it's consistent on the document!\n\t\t\t\t\tlet bodyStyle = _body.style,\n\t\t\t\t\t\tborder = bodyStyle.borderTop,\n\t\t\t\t\t\tbounds;\n\t\t\t\t\tbodyStyle.borderTop = \"1px solid #000\"; // works around an issue where a margin of a child element could throw off the bounds of the _body, making it seem like there's a margin when there actually isn't. The border ensures that the bounds are accurate.\n\t\t\t\t\tbounds = _getBounds(_body);\n\t\t\t\t\t_vertical.m = Math.round(bounds.top + _vertical.sc()) || 0; // accommodate the offset of the <body> caused by margins and/or padding\n\t\t\t\t\t_horizontal.m = Math.round(bounds.left + _horizontal.sc()) || 0;\n\t\t\t\t\tborder ? (bodyStyle.borderTop = border) : bodyStyle.removeProperty(\"border-top\");\n\t\t\t\t\t_syncInterval = setInterval(_sync, 200);\n\t\t\t\t\tgsap.delayedCall(0.5, () => _startup = 0);\n\t\t\t\t\t_addListener(_doc, \"touchcancel\", _passThrough); // some older Android devices intermittently stop dispatching \"touchmove\" events if we don't listen for \"touchcancel\" on the document.\n\t\t\t\t\t_addListener(_body, \"touchstart\", _passThrough); //works around Safari bug: https://greensock.com/forums/topic/21450-draggable-in-iframe-on-mobile-is-buggy/\n\t\t\t\t\t_multiListener(_addListener, _doc, \"pointerdown,touchstart,mousedown\", () => _pointerIsDown = 1);\n\t\t\t\t\t_multiListener(_addListener, _doc, \"pointerup,touchend,mouseup\", () => _pointerIsDown = 0);\n\t\t\t\t\t_transformProp = gsap.utils.checkPrefix(\"transform\");\n\t\t\t\t\t_stateProps.push(_transformProp);\n\t\t\t\t\t_coreInitted = _getTime();\n\t\t\t\t\t_resizeDelay = gsap.delayedCall(0.2, _refreshAll).pause();\n\t\t\t\t\t_autoRefresh = [_doc, \"visibilitychange\", () => {\n\t\t\t\t\t\tlet w = _win.innerWidth,\n\t\t\t\t\t\t\th = _win.innerHeight;\n\t\t\t\t\t\tif (_doc.hidden) {\n\t\t\t\t\t\t\t_prevWidth = w;\n\t\t\t\t\t\t\t_prevHeight = h;\n\t\t\t\t\t\t} else if (_prevWidth !== w || _prevHeight !== h) {\n\t\t\t\t\t\t\t_onResize();\n\t\t\t\t\t\t}\n\t\t\t\t\t}, _doc, \"DOMContentLoaded\", _refreshAll, _win, \"load\", () => _lastScrollTime || _refreshAll(), _win, \"resize\", _onResize];\n\t\t\t\t\t_iterateAutoRefresh(_addListener);\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn _coreInitted;\n\t}\n\n\tstatic defaults(config) {\n\t\tfor (let p in config) {\n\t\t\t_defaults[p] = config[p];\n\t\t}\n\t}\n\n\tstatic kill() {\n\t\t_enabled = 0;\n\t\t_triggers.slice(0).forEach(trigger => trigger.kill(1));\n\t}\n\n\tstatic config(vars) {\n\t\t(\"limitCallbacks\" in vars) && (_limitCallbacks = !!vars.limitCallbacks);\n\t\tlet ms = vars.syncInterval;\n\t\tms && clearInterval(_syncInterval) || ((_syncInterval = ms) && setInterval(_sync, ms));\n\t\t(\"autoRefreshEvents\" in vars) && (_iterateAutoRefresh(_removeListener) || _iterateAutoRefresh(_addListener, vars.autoRefreshEvents || \"none\"));\n\t}\n\n\tstatic scrollerProxy(target, vars) {\n\t\tlet t = _toArray(target)[0];\n\t\t_isViewport(t) ? _proxies.unshift(_win, vars, _body, vars, _docEl, vars) : _proxies.unshift(t, vars);\n\t}\n\n\tstatic matchMedia(vars) {\n\t\tlet mq, p;\n\t\tfor (p in vars) {\n\t\t\tif (p === \"all\") {\n\t\t\t\t_creatingMedia = p;\n\t\t\t\tvars[p]();\n\t\t\t\t_creatingMedia = 0;\n\t\t\t} else {\n\t\t\t\tmq = _win.matchMedia(p);\n\t\t\t\tif (mq) {\n\t\t\t\t\t_media.push(p, vars[p]);\n\t\t\t\t\tmq.addListener ? mq.addListener(_onMediaChange) : mq.addEventListener(\"change\", _onMediaChange);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t_onMediaChange();\n\t\treturn _media;\n\t}\n\n}\n\nScrollTrigger.version = \"3.4.0\";\nScrollTrigger.saveStyles = targets => targets ? _toArray(targets).forEach(target => {\n\tlet i = _savedStyles.indexOf(target);\n\ti >= 0 && _savedStyles.splice(i, 4);\n\t_savedStyles.push(target, target.style.cssText, gsap.core.getCache(target), _creatingMedia);\n}) : _savedStyles;\nScrollTrigger.revert = (soft, media) => _revertAll(!soft, media);\nScrollTrigger.create = (vars, animation) => new ScrollTrigger(vars, animation);\nScrollTrigger.refresh = safe => safe ? _onResize() : _refreshAll(true);\nScrollTrigger.update = _updateAll;\nScrollTrigger.maxScroll = (element, horizontal) => _maxScroll(element, horizontal ? _horizontal : _vertical);\nScrollTrigger.getScrollFunc = (element, horizontal) => _getScrollFunc(_toArray(element)[0], horizontal ? _horizontal : _vertical);\nScrollTrigger.getById = id => _ids[id];\nScrollTrigger.getAll = () => _triggers.slice(0);\nScrollTrigger.isScrolling = () => !!_lastScrollTime;\nScrollTrigger.addEventListener = (type, callback) => {\n\tlet a = _listeners[type] || (_listeners[type] = []);\n\t~a.indexOf(callback) || a.push(callback);\n};\nScrollTrigger.removeEventListener = (type, callback) => {\n\tlet a = _listeners[type],\n\t\ti = a && a.indexOf(callback);\n\ti >= 0 && a.splice(i, 1);\n};\nScrollTrigger.batch = (targets, vars) => {\n\tlet result = [],\n\t\tvarsCopy = {},\n\t\tinterval = vars.interval || 0.016,\n\t\tbatchMax = vars.batchMax || 1e9,\n\t\tproxyCallback = (type, callback) => {\n\t\t\tlet elements = [],\n\t\t\t\ttriggers = [],\n\t\t\t\tdelay = gsap.delayedCall(interval, () => {callback(elements, triggers); elements = []; triggers = [];}).pause();\n\t\t\treturn self => {\n\t\t\t\telements.length || delay.restart(true);\n\t\t\t\telements.push(self.trigger);\n\t\t\t\ttriggers.push(self);\n\t\t\t\tbatchMax <= elements.length && delay.progress(1);\n\t\t\t};\n\t\t},\n\t\tp;\n\tfor (p in vars) {\n\t\tvarsCopy[p] = (p.substr(0, 2) === \"on\" && _isFunction(vars[p]) && p !== \"onRefreshInit\") ? proxyCallback(p, vars[p]) : vars[p];\n\t}\n\tif (_isFunction(batchMax)) {\n\t\tbatchMax = batchMax();\n\t\t_addListener(ScrollTrigger, \"refresh\", () => batchMax = vars.batchMax());\n\t}\n\t_toArray(targets).forEach(target => {\n\t\tlet config = {};\n\t\tfor (p in varsCopy) {\n\t\t\tconfig[p] = varsCopy[p];\n\t\t}\n\t\tconfig.trigger = target;\n\t\tresult.push(ScrollTrigger.create(config));\n\t});\n\treturn result;\n}\n\n_getGSAP() && gsap.registerPlugin(ScrollTrigger);\n\nexport { ScrollTrigger as default };"],"names":["_passThrough","v","_windowExists","window","_getGSAP","gsap","registerPlugin","_isViewport","e","_root","indexOf","_getProxyProp","element","property","_proxies","_getScrollFunc","s","sc","i","_scrollers","func","value","arguments","length","push","_getBoundsFunc","_winOffsets","width","_win","innerWidth","height","innerHeight","_getBounds","_maxScroll","d2","d","a","Math","max","_docEl","_body","_iterateAutoRefresh","events","_autoRefresh","_isString","_isFunction","_isNumber","_isObject","_getComputedStyle","getComputedStyle","_setDefaults","obj","defaults","p","_getSize","_multiListener","types","callback","split","forEach","type","_addListener","addEventListener","passive","_removeListener","removeEventListener","_offsetToPx","size","eqIndex","relative","charAt","parseFloat","substr","_keywords","_createMarker","name","container","direction","offset","matchWidthEl","startColor","endColor","fontSize","indent","fontWeight","_doc","createElement","useFixedPosition","isScroller","parent","isStart","color","css","_vertical","_right","_bottom","offsetWidth","_isStart","setAttribute","style","cssText","innerText","insertBefore","children","_offset","op","_positionMarker","_sync","_request","_raf","_updateAll","_onScroll","_lastScrollTime","_dispatch","_getTime","_onResize","_refreshing","_resizeDelay","restart","_onMediaChange","tick","ticker","frame","matches","_lastMediaTick","_revertAll","_media","matchMedia","_revertRecorded","_creatingMedia","_refreshAll","_softRefresh","ScrollTrigger","_swapPinOut","pin","spacer","state","_setState","parentNode","removeChild","_swapPinIn","cs","_propNamesToCopy","spacerStyle","pinStyle","position","display","overflow","boxSizing","_width","_horizontal","_px","_height","_padding","_margin","_top","_left","appendChild","_getState","l","_stateProps","t","_parsePosition","trigger","scrollerSize","scroll","marker","markerScroller","self","scrollerBounds","borderWidth","scrollerMax","localOffset","globalOffset","_toArray","bounds","offsets","left","top","removeProperty","m","round","_getTweenCreator","scroller","lastScroll","getScroll","prop","p2","getTween","scrollTo","vars","initialValue","change1","change2","tween","onComplete","modifiers","kill","abs","ratio","call","to","_coreInitted","_clamp","_time2","_syncInterval","_pointerIsDown","_transformProp","_i","_prevWidth","_prevHeight","_limitCallbacks","_startup","Date","now","_time1","_enabled","_abs","_scrollLeft","_scrollTop","_Right","_Left","_Top","_Bottom","_Width","_Height","os","os2","pageXOffset","pageYOffset","withoutTransforms","x","y","xPercent","yPercent","rotation","rotationX","rotationY","scale","skewX","skewY","progress","getBoundingClientRect","_markerDefaults","_defaults","toggleActions","anticipatePin","center","bottom","right","start","flipped","side","oppositeSide","_isFlipped","set","_triggers","_ids","_listeners","_emptyArray","map","f","_savedStyles","media","uncache","rec","revert","force","skipRevert","refreshInits","refresh","result","render","time","recordVelocity","update","concat","_capsExp","replace","toLowerCase","_prefixExp","init","animation","this","tweenTo","pinCache","snapFunc","isReverted","scroll1","scroll2","end","markerStart","markerEnd","markerStartTrigger","markerEndTrigger","markerVars","change","pinOriginalState","pinActiveState","pinState","pinGetter","pinSetter","pinStart","pinChange","spacingStart","spacingActive","markerStartSetter","markerEndSetter","snap1","snap2","scrubScrollTime","scrubTween","scrubSmooth","snapDurClamp","snapDelayedCall","enabled","prevProgress","prevScroll","prevAnimProgress","nodeType","horizontal","onUpdate","toggleClass","id","onToggle","onRefresh","scrub","pinSpacing","invalidateOnRefresh","onScrubComplete","onSnapComplete","once","snap","pinReparent","isToggle","scrollerCache","core","getCache","isViewport","callbacks","onEnter","onLeave","onEnterBack","onLeaveBack","markers","onRefreshInit","getScrollerSize","_getSizeFunc","getScrollerOffsets","_getOffsetsFunc","tweenScroll","lazy","_initted","immediateRender","pause","scrollTrigger","ease","duration","snapTo","scrollBehavior","_getLabels","labels","utils","min","delayedCall","delay","totalProgress","velocity","naturalEnd","endValue","endScroll","data","targets","className","force3D","getProperty","quickSetter","_makePositionable","r","prevRefreshing","soft","invalidate","isVertical","override","curTrigger","otherPinOffset","parsedEnd","parsedEndTrigger","endTrigger","parsedStart","pinIndex","_pinPush","ceil","_copyState","omitOffsets","splice","_pinOffset","getVelocity","reset","isActive","toggleState","action","stateChanged","toggled","clipped","_reparent","_stOrig","test","el","classList","enable","add","disable","register","document","documentElement","body","toArray","clamp","globals","requestAnimationFrame","setTimeout","bodyStyle","border","borderTop","setInterval","checkPrefix","w","h","hidden","config","slice","limitCallbacks","ms","syncInterval","clearInterval","autoRefreshEvents","scrollerProxy","target","unshift","mq","addListener","console","warn","version","saveStyles","create","safe","maxScroll","getScrollFunc","getById","getAll","isScrolling","batch","proxyCallback","elements","triggers","interval","batchMax","varsCopy"],"mappings":"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"}